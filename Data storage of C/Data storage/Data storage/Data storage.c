#define _CRT_SECURE_NO_WARNINGS


//		c语言中数据类型：
//	1.内置类型
//	2.自定义类型
//		类型的意义：
//	1.使用这个类型开辟的内存空间的大小
//	2.如何看待内存空间的视角

//整形家族：
//	char
//		unsigned char	0-255
//		signed char		-128--127
//	short
//	int
//	long		同上
//有符号：内存首位认定为符号位

//构造类型：
//	数组类型
//	结构体类型
//	枚举类型enum
//	联合类型union

//指针类型
//	int *p；
//	char *pc；
//	float* pf；
//	void* pv；

//空类型：
// void表示空类型（无类型）
//通常应用于函数的返回类型、函数的参数、指针类型	void function（void）；意味着函数不需要传参

//整型在内存中的存储
//int main()
//{
//	int a = 20;//4个字节-32bit
//	//00000000000000000000000000010100 - 原码
//	//00000000000000000000000000010100 - 反码
//	//00000000000000000000000000010100 - 补码
//	//0x00000014
//	int b = -10;
//	//10000000000000000000000000001010 - 原码
//	//11111111111111111111111111110101 - 反码
//	//1111 1111 1111 1111 1111 1111 1111 0110 - 补码
//	//0xFFFFFFF6
//
//	return 0;
//}
//使用补码，可以将符号域与数值域统一处理。同时，加法与减法也可以统一处理（CPU只有加法器）；此外，补码与原码相互转换，其运算方式相同，不需要额外的硬件电路
//我宣布想出三码存储的人是个天才！		——你又宣布上了？！回去等通知去。
//
//对于整形来说		其在内存中存储的都是补码

//什么是大端小端:大（小）端字节序存储模式
//大端(存储)模式，是指数据的低位保存在内存的高地址中, 而数据的高位, 保存在内存的低地址中;
//小端(存储)模式, 是指数据的低位保存在内存的低地址中。而数据的高位，保存在内存的高地址中。
// 本机采取小端存储
//所以上面a，b在内存中其实是反着排的(doge)
//为什么会有大端小端
//为什么会有大小端模式之分呢?这是因为在计算机系统中。我们是以字节为单位的。每个地址单元都对应着一
//个字节, 一个字节为8bit.但是在C语言中除了8bit的char之外, 还有16bit的short型, 32bit的long型(要看具
//	体的编译器)，另外, 对于位数大于8位的处理器, 例如16位或者32位的处理器, 由于寄存器宽度大于一一个字
//	节.那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。
//	例如一个16bit的short型x, 在内存中的地址为0x0010，x的值为0x1122.那么 0x11为高字节。0x22
//	为低字节。对于大端模式, 就将0x11放在低地址中,即 0x0010中，0x22 放在高地址中, 即0x0011中。小
//	端模式，刚好相反。我们常用的X86结构是小端模式, 而KEIL C51 则为大端模式。很多的ARM，DSP都为小
//	端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。
//
#include<stdio.h>
//int check_sys()
//{
//	int a = 1;
//	//char* p = (char*)&a;			//强制类型转换可以去警告
//	//return *p;
//	return *(char*)&a;
//}
//int main()
//{
//	//简单地判断机器是大端存储还是小端存储
//	//返回1 小端；返回0  大端
//	int ret=check_sys();
//	if(ret)
//		printf("小端");
//	else
//		printf("大端");
//	return 0;
//}
//
//
//int main()
//{
//	char a = -1;
//	// -1
//	//10000000000000000000000000000001		原码
//	//11111111111111111111111111111110		反码
//	//11111111111111111111111111111111		补码
//	//a—— 11111111
//	// 打印整型——整型提升
//	// 有符号补最高位
//	//11111111111111111111111111111111		补码
//	//b—— 11111111
//	// 同a
//	//c—— 11111111
//	//unsigned 整型提升补0
//	//00000000000000000000000011111111
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("%d %d %d",a,b, c);
//	char d = -128;
//	printf(" %u", d);
//	//4294967168
//	//10000000000000000000000010000000		原
//	//11111111111111111111111101111111		反
//	//11111111111111111111111110000000		补
//	// 截断存储
//	//10000000
//	// 提升
//	//11111111111111111111111110000000
//	//%u 打印十进制无符号数
//	//相当于直接输出补码的值
//	char e = 128;//char存不到128；127+1=-128；
//	printf(" %u", e);
//}
//10000000  ——直接得到-128
//https://blog.csdn.net/m0_52089596/article/details/114397911
//int main() {
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	//按照补码的形式进行运算，最后格式化成为有符号整数
//  //11111111 11111111 11111111 11110110	-结果 
//}
//#include<string.h>
//int main()
//{
//	//char a[1000] ;
//	//int i;
//	//for (i = 0; i < 1000; i++)
//	//{
//	//	a[i] = -1 - i;
//	//}
//	//printf("%d", strlen(a));
//	//unsigned char i = 0;
//	//for (i = 0; i <= 255; i++)
//	//{
//	//	printf("这是怎么回事呢\n");
//	//}
//	//死循环 因为unsigned char最大也就255
//}



////浮点数在内存中的存储
//// float、 double、 long double
//int main()
//{
//	int n = 9;
//	//0 00000000 00000000000000000001001	补码
//	
// float* pFloat = (float*)&n;
//	printf("n的值为%d\n", n);					//9
//	printf("*pFloat的值为%f\n", *pFloat);		//0.000000
//	//(-1)^0*0.00000000000000000001001*2^-126
// 
//	*pFloat = 9.0; 
//	printf("n的值为%d\n", n);					//1091567616
//	printf("*pFloat的值为%f\n", *pFloat);		//9.000000
//
//	return 0;
//
//}
// 9.0
// 1001.0
// (-1)^0*1.001*2^3
// (-1)^S*M	   *2^E
//浮点数V的存储：
//	(-1)^S*M*2^E
//	(-1)^S表示符号位，当s=0，V为正数，s=1，V为负数
//	M表示有效数字，大于等于1，小于2；
//	2^E表示指数位
//
//		只需保存S M E
//	IEEE 754规定：对于32位的浮点数(float)，最高一位是符号位，接着8位是指数E，剩下23位是有效数字M；
//				：队于64位的浮点数(double),最高一位是符号位S；接着11位是指数E，剩下的是有效数字M；
//		由于科学计数法的E可以出现负数，而存储中按无符号的形式存储，所以IEEE 754 规定 存入内存时的E的真实值必须再加上一个中间数；
//		对于8位的E，这个中间数是127，对于11位的E，这个中间数是1023		比如2^10的E是10，保存成32位浮点数是必须保存成10+127=137；
//
//	指数E从内存中取出的情况分三种：
//		1.E不全为0或不全为1(常规情况)：	
//			这时，E的存储值减去中间值得到E的真实值，再将有效数字M前加上第一位的1
//		2.E全为0
//			这时，指数E的真实值等于(1-中间值)，有效数字M不再加上第一位的1，而是还原为0.xxxxxx
//			这样做是为了表示+-0  以及接近于0的很小的数字
//		3.E全为1
//			这时，如果有效数字M全为0，表示+-无穷大，（正负取决于符号位）
//			



